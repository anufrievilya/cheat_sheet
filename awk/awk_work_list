Построчный разбор и обработка входного потока, по заданным шаблонам.
Это полноценный язык программирования. Схема вызова:
$ awk options program file
awk ждёт текст программы - поэтому в одинарных ковычках(т.к. текст) а сама прога в скобках..
awk '{ print $2 }' file1

$0 — представляет всю строку текста (запись).
$1 — первое поле.
$2 — второе поле.
$n — n-ное поле

-F  - указать разделитель полей. По умолчанию это проблелы и табы.
$ awk -F: '{print $1}' /etc/passwd

замена в строке на определённое значение, несколько команд в одной строке, через ;
$ echo "My name is Tom" | awk '{$4="Adam"; print $0}'

Можно хранить скрипты в файлах. Для вызова использовать ключ -f
testfile   - {print $1 " has a  home directory at " $6}
awk -F: -f testfile /etc/passwd

Можно несколько команд, просто в несколько строк в файле:
{
text = " HOME DIR "
print $1 text $6
}

Выполнение команд до начала обработки данных.
awk 'BEGIN {print "hi"}'
Выполнение команд после окончания обработки данных.
awk 'BEGIN {print "Hi"}
{print $0}
END {print "End" }'  file2

Тестовый скрипт myscript:  (awk -f myscript  /etc/passwd)
BEGIN {
print "The latest list of users and shells"
print " UserName \t HomePath"
print "-------- \t -------"
FS=":"
}
{
print $1 " \t " $6
}
END {
print "The end"
}

Встроенные переменные:
FIELDWIDTHS — разделённый пробелами список чисел, определяющий точную ширину каждого поля данных с учётом разделителей полей.
FS — уже знакомая вам переменная, позволяющая задавать символ-разделитель полей.
RS — переменная, которая позволяет задавать символ-разделитель записей.
OFS — разделитель полей на выводе aw
k-скрипта.
ORS — разделитель записей на выводе awk-скрипта.
Выведет в разделителе вместо пробела будет -
$ awk 'BEGIN{FS=":"; OFS="-"} {print $1,$6,$7}' /etc/passwd

Переменная FIELDWIDTHS позволяет читать записи без использования символа-разделителя полей. (забивает на FS)
testfile: ( набор данных в одну строку, без разделителей. Но мы знаем как разделить эту голиматью)
1235.9652147.91
927-8.365217.27
36257.8157492.5

awk 'BEGIN{FIELDWIDTHS="3 5 2 5"}{print $1,$2,$3,$4}' testfile
123 5.965 21 47.91
927 -8.36 52 17.27
362 57.81 57 492.5

awk - воспринимает строки из файла как поля, а разделителями становятся пустые строки.
RS - разделитель строк- то как awk понимает разделение строк. Где перевод строки, по умолчанию /n.
addresses:  Блоки строк, разделенных пустой строкой.
Person Name
123 High Street
(222) 466-1234

Another person
487 High Street
(523) 643-8754

Символ разделяющий поля - перевод строки \n.  Символ указывающий на конец строки - "" - пустая строка.
$ awk 'BEGIN{FS="\n"; RS=""} {print $1,$3}' addresses
Person Name (222) 466-1234
Another person (523) 643-8754


Встроенные переменные:сведения о данных и об окружении
ARGC — количество аргументов командной строки.
ARGV — массив с аргументами командной строки.
ARGIND — индекс текущего обрабатываемого файла в массиве ARGV.
ENVIRON — ассоциативный массив с переменными окружения и их значениями.
ERRNO — код системной ошибки, которая может возникнуть при чтении или закрытии входных файлов.
FILENAME — имя входного файла с данными.
FNR — номер текущей записи в файле данных.
IGNORECASE — если эта переменная установлена в ненулевое значение, при обработке игнорируется регистр символов.
NF — общее число полей данных в текущей записи.
NR — общее число обработанных записей.


awk 'BEGIN{print ARGC,ARGV[1]}' fieldwiths
2 fieldwiths

показать переменные среды
awk '
BEGIN{
print ENVIRON["HOME"]
print ENVIRON["PATH"]
}'
Вывод:
/root
/usr/local/sbin:/sbin:/bin:/usr/sbin:/usr/bin:/opt/puppetlabs/bin:/root/bin

$  echo | awk -v home=$HOME '{print "My home is " home}'

Переменная NF позволяет обращаться к последнему полю данных в записи, не зная его точной позиции:
awk 'BEGIN{FS=":"; OFS=":"} {print $1,$NF}' /etc/passwd

Имена переменных могут включать в себя буквы, цифры, символы подчёркивания. Однако, они не могут начинаться с цифры. 
$ awk '
BEGIN{
test="This is a test"
print test
}'

Условный оператор
awk '{print $2}' services | awk -F/ '{print $1}' > services3
скрипт с условным оператором
BEGIN{
print "Hi"
}

{
if ($1 > 100)
{
        if ($1 < 120)
        {
        x = $1 * 2
        print x
        }
}
}
Запуск на выполнение:
 awk -f arif services2
 
Может содержать оператор else
awk '{
if ($1 > 20)
{
x = $1 * 2
print x
} else
{
x = $1 / 2
print x
}}' testfile
 
 awk '{if ($1 > 20) print $1 * 2; else print $1 / 2}' testfile

Цикл while
Цикл while позволяет перебирать наборы данных, проверяя условие, которое остановит цикл.

myfile:
124 127 130
112 142 135
175 158 245
vim average
BEGIN {
print "average:"
}
{
total=0
i=1
while (i<4)
        {
        total += $i
        i++
        }
avg=total/3
print "Average:", avg
}

awk -f average myfile
average:
Average: 127
Average: 129.667
Average: 192.667

В циклах while можно использовать команды break и continue. 
Первая позволяет досрочно завершить цикл и приступить к выполнению команд, расположенных после него
awk '{
total = 0
i = 1
while (i < 4)
{
total += $i
if (i == 2)
break
i++
}
avg = total / 2
print "The average of the first two elements is:",avg
}' testfile


